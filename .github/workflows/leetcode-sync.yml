name: LeetCode Sync (robust)

on:
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          persist-credentials: true

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: python -m pip install --upgrade pip && pip install requests

      - name: Configure git user
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Add robust leetcode_sync.py
        run: |
          cat > leetcode_sync.py <<'PY'
#!/usr/bin/env python3
"""
Robust leetcode_sync.py
- Fetches all submissions (paginated).
- Commits accepted submissions with original submission timestamps.
- Skips existing files and maintains a small state file for resume.
Designed for large imports (hundreds or thousands).
Environment:
  - LEETCODE_SESSION (required)
  - REPO_PATH (optional, defaults to current workspace)
  - BRANCH (optional, default "main")
"""
import os, sys, time, json, requests, subprocess
from pathlib import Path
from datetime import datetime, timezone

LEETCODE_SESSION = os.environ.get("LEETCODE_SESSION")
REPO_PATH = Path(os.environ.get("REPO_PATH", os.getcwd()))
BRANCH = os.environ.get("BRANCH", "main")

if not LEETCODE_SESSION:
    print("ERROR: LEETCODE_SESSION not set. Add it in repo secrets.")
    sys.exit(1)

if not (REPO_PATH.exists() and (REPO_PATH / ".git").exists()):
    print(f"ERROR: REPO_PATH {REPO_PATH} not found or not a git repo.")
    sys.exit(1)

# Where we store progress so runs can resume
STATE_FILE = REPO_PATH / ".leetcode_sync_state.json"

# Language -> extension
EXT_MAP = {
    "cpp": "cpp", "c++": "cpp", "java": "java", "python": "py", "python3": "py",
    "c": "c", "c#": "cs", "csharp": "cs", "javascript": "js", "ruby": "rb",
    "swift": "swift", "go": "go", "rust": "rs", "kotlin": "kt", "scala": "scala",
    "php": "php",
}

session = requests.Session()
session.cookies.set("LEETCODE_SESSION", LEETCODE_SESSION, domain=".leetcode.com")
session.headers.update({"User-Agent":"github-action-leetcode-sync/1.0","Referer":"https://leetcode.com"})

API_BASE = "https://leetcode.com/api/submissions/"

def run_git(args, env=None):
    full_env = os.environ.copy()
    if env:
        full_env.update(env)
    res = subprocess.run(["git"] + args, cwd=str(REPO_PATH), env=full_env, text=True,
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if res.returncode != 0:
        print("Git failed:", res.returncode, res.stdout, res.stderr)
        raise SystemExit(res.returncode)
    return res.stdout.strip()

def load_state():
    if STATE_FILE.exists():
        try:
            return json.loads(STATE_FILE.read_text(encoding="utf-8"))
        except Exception:
            return {}
    return {}

def save_state(state):
    STATE_FILE.write_text(json.dumps(state, indent=2), encoding="utf-8")

def safe_filename(s):
    return "".join(c if c.isalnum() or c in "-." else "" for c in s)

def fetch_all_submissions(limit=50, sleep_between=0.2):
    subs = []
    offset = 0
    while True:
        url = f"{API_BASE}?offset={offset}&limit={limit}"
        r = session.get(url, timeout=30)
        if r.status_code != 200:
            print("Failed to fetch submissions:", r.status_code)
            print("Response snippet:", r.text[:400])
            break
        data = r.json()
        batch = data.get("submissions_dump") or data.get("submissions") or []
        if not batch:
            break
        subs.extend(batch)
        if len(batch) < limit:
            break
        offset += limit
        time.sleep(sleep_between)
    return subs

def write_and_commit(sub):
    status = (sub.get("status_display") or sub.get("status") or "").lower()
    if ("accepted" not in status) and (not status.startswith("ac")):
        return False

    title_slug = sub.get("title_slug") or sub.get("title") or f"problem_{sub.get('id','')}"
    title = sub.get("title") or title_slug
    lang = (sub.get("lang") or sub.get("language") or "").lower()
    ts = int(sub.get("timestamp") or sub.get("time") or 0)
    code = sub.get("code") or sub.get("submission_code") or ""
    if not code or ts == 0:
        return False

    ext = EXT_MAP.get(lang, "txt")
    prob_dir = REPO_PATH / safe_filename(title_slug)
    prob_dir.mkdir(parents=True, exist_ok=True)

    dt = datetime.fromtimestamp(ts, tz=timezone.utc)
    iso = dt.strftime("%Y-%m-%dT%H-%M-%SZ")
    sub_id = sub.get("id") or sub.get("submission_id") or ""
    filename = f"{iso}{sub_id}{lang}.{ext}"
    file_path = prob_dir / filename

    if file_path.exists():
        # Already exists - skip
        return False

    # Write file
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(f"// LeetCode: {title} ({title_slug})\n")
        f.write(f"// Submission ID: {sub_id}\n")
        f.write(f"// Language: {lang}\n")
        f.write(f"// Timestamp (UTC): {iso}\n\n")
        f.write(code)

    commit_msg = f"Add LeetCode: {title} ({title_slug}) — solved on {iso}"
    env = {
        "GIT_AUTHOR_DATE": dt.strftime("%Y-%m-%dT%H:%M:%SZ"),
        "GIT_COMMITTER_DATE": dt.strftime("%Y-%m-%dT%H:%M:%SZ"),
    }

    run_git(["add", str(file_path)])
    run_git(["commit", "-m", commit_msg], env=env)
    print("Committed", file_path, "date", env["GIT_AUTHOR_DATE"])
    return True

def main():
    state = load_state()
    last_processed = state.get("last_processed_id")  # optional checkpoint
    print("State loaded. last_processed_id:", last_processed)

    print("Fetching submissions (this may take a while for 1000 items)...")
    subs = fetch_all_submissions(limit=50, sleep_between=0.25)
    print("Total submissions fetched:", len(subs))

    # We want oldest first so git history is chronological
    subs_sorted = list(reversed(subs))

    created = 0
    for sub in subs_sorted:
        sub_id = str(sub.get("id") or sub.get("submission_id") or "")
        # If previously processed, skip
        if state.get("processed_ids") and (sub_id in state["processed_ids"]):
            continue
        try:
            changed = write_and_commit(sub)
            if changed:
                created += 1
            # Record it as processed even if no file created, to avoid reprocessing
            state.setdefault("processed_ids", {})[sub_id] = {
                "title": sub.get("title"),
                "ts": sub.get("timestamp") or sub.get("time")
            }
            state["last_processed_id"] = sub_id
            save_state(state)
        except Exception as e:
            print("Error processing submission id", sub_id, " — ", e)
            # save progress and exit so you can re-run later
            save_state(state)
            raise

    print("Done. Created commits:", created)

    # push once at end (if many commits, pushing once is faster)
    try:
        run_git(["push", "origin", BRANCH])
        print("Pushed changes to branch", BRANCH)
    except Exception as e:
        print("Push failed:", e)

if _name_ == "_main_":
    main()
PY

      - name: Run leetcode sync (robust)
        env:
          LEETCODE_SESSION: ${{ secrets.LEETCODE_SESSION }}
          REPO_PATH: ${{ github.workspace }}
          BRANCH: main
        run: |
          python leetcode_sync.py
